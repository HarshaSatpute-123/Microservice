
name: CI/CD to AKS

on:
  push:
    branches: [ "main" ]

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Login to ACR
      - name: Login to ACR
        run: |
          echo "${{ secrets.ACR_PASSWORD }}" | docker login ${{ secrets.ACR_LOGIN_SERVER }} \
            --username "${{ secrets.ACR_USERNAME }}" --password-stdin

      # Build Docker image
      - name: Build Docker image
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/placeholder:${{ github.sha }}
          docker build -t $IMAGE .
          echo "Image built: $IMAGE"

      # Push Docker image
      - name: Push Docker image
        run: |
          IMAGE=${{ secrets.ACR_LOGIN_SERVER }}/placeholder:${{ github.sha }}
          docker push $IMAGE
          echo "Image pushed: $IMAGE"

      # Setup kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      # Load kubeconfig from secret (raw YAML)
      # If your secret is BASE64-encoded, see the alternative block below.
      - name: Load kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG }}" > $PWD/kubeconfig
          chmod 600 $PWD/kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      # (Alternative) If your kubeconfig secret is BASE64-encoded, use this instead:
      # - name: Load kubeconfig (base64)
      #   run: |
      #     echo "${{ secrets.KUBECONFIG_B64 }}" | base64 -d > $PWD/kubeconfig
      #     chmod 600 $PWD/kubeconfig
      #     echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      # Verify cluster connectivity before deploying
      - name: Verify AKS connectivity
        run: |
          kubectl config get-contexts
          kubectl config current-context
          kubectl cluster-info
          kubectl get nodes

      # Apply deployment YAML
      - name: Deploy to AKS
        run: |
          kubectl apply -f deployment.yaml --kubeconfig "$KUBECONFIG"

      # Update container image deterministically and wait for rollout
      - name: Update container image and rollout
        env:
          IMAGE: ${{ secrets.ACR_LOGIN_SERVER }}/placeholder:${{ github.sha }}
          NAMESPACE: default             # <-- change if your YAML uses another namespace
          DEPLOYMENT_NAME: placeholder   # <-- change to match metadata.name in deployment.yaml
          CONTAINER_NAME: placeholder    # <-- change to the container name in the deployment spec
        run: |
          # If you prefer dynamic selection, use labels:
          # DEPLOYMENT_NAME=$(kubectl -n "$NAMESPACE" get deploy -l app=placeholder -o jsonpath='{.items[0].metadata.name}')

          kubectl -n "$NAMESPACE" set image deployment/$DEPLOYMENT_NAME $CONTAINER_NAME="$IMAGE" --kubeconfig "$KUBECONFIG"
          kubectl -n "$NAMESPACE" rollout status deployment/$DEPLOYMENT_NAME --timeout=180s --kubeconfig "$KUBECONFIG"
``
